Это относится к ООП

[Объяснение на Python](https://webdevblog.ru/glubokoe-i-poverhnostnoe-kopirovanie-v-python/)

**Поверхностное копирование** создает отдельный новый объект, но вместо копирования дочерних элементов в новый объект, оно просто копирует ссылки на их адреса памяти. Следовательно, если вы сделаете изменение в исходном объекте, оно будет отражено в скопированном объекте, и наоборот. Обе копии зависят друг от друга

**Глубокое копирование** создает новую и отдельную копию всего объекта со своим уникальным адресом памяти. Это означает, что любые изменения в новой копии объекта не будут отражаться в исходной. Этот процесс происходит следующим образом, сначала создается новый объект, а затем копируются все элементы из исходного в новый

[Объяснение на С++](https://ravesli.com/urok-145-poverhnostnoe-i-glubokoe-kopirovanie/#toc-0)

**При поверхностном копировании указателя копируется только адрес, который хранит указатель — никаких действий по содержимому адреса указателя не предпринимается**. Это означает, что C++ выполняет копирование для каждого члена класса индивидуально (используя оператор присваивания по умолчанию вместо перегрузки оператора присваивания и прямую инициализацию вместо конструктора копирования). Если мы не определяем свой конструктор копирования или перегрузку оператора присваивания, то язык C++ предоставит конструктор копирования и оператор присваивания по умолчанию, которые будут выполнять поверхностное копирование

**При глубоком копировании память сначала выделяется для копирования адреса, который содержит исходный указатель, а затем для копирования фактического значения**. Таким образом копия находится в отдельной, от исходного значения, памяти и они никак не влияют друг на друга. Для выполнения глубокого копирования нам необходимо написать свой собственный конструктор копирования и перегрузку оператора присваивания